# Optimal-Binary-Search-Tree
Implementation of a BST with optimization algorithm 

A binary search tree is a data structure which supports fast searching. Each node of the structure contains, in addition to data, pointers to at most two other nodes. One points to a node containing data less than the node in question, and the other points to a node containing data greater than the node in question. Given a series of potential members there are many different ways to assemble a BST. A poorly balanced BST, for example, might contain a ‘root’ node which is the smallest member of the data set. Such a tree would lack entirely a ‘smaller-than’ sub-tree and, as a result, search time would not be ideal. An optimal binary search tree is assembled such that higher priority data is stacked towards the top of the tree, closer to the tree’s root. An OBST is structured in the typical BST fashion and also balanced in favor of data more likely to be searched for. 
I first converted an old BST implementation I wrote to handle strings. One problem with this implementation is that it only considers the first character of a word when judging a member’s size. Two words that have the same initial character are treated, by the BST, as equivalent inputs. Though I did not see this feature as a problem for the project of creating an optimization algorithm, clearly it is an undesirable feature. 
	The optimization algorithm constructs the OBST from the bottom up, using dynamic programming. As input the algorithm takes a sorted array of members and an array of probabilities corresponding to each member. The algorithm produces a table which contains information concerning the ideal roots for each sub-tree of the OBST. The table is then read by a recursive function which assembles the OBST. 
	  
